﻿﻿﻿﻿# Explanation for Problem 4: Active Directory**Author:** Moya RichardsThis document provides a text explanation of the efficiency of the code and the design choices.------------------------## Project Summary|  | Summary Details || -------------- | --------------- || Efficiency | O(u * g) - time complexity, and O(u *g space complexity <br><br> u represents the list of users and g represents the list of groups|| Data Structure | List|## Design Choices### Data Structures Used| Data Structure |Information  |Time Complexity | Space Complexity || -------------- | --------------- | ---------------- | ---------------- || list |list of users | O(u) |O(u)|| list |list of groups | O(g) |O(g)|This project is about finding the user within a group or it's subgroups. If a user is found in a group, the subsequent groups are not searched.------------I am not sure if I am allowed to change the original class, so I  created two versions of the solution to the problem. The key thing to note is that the  is_user_in_group() function is the same for both versions.```pythondef findUser(user, group):    """Checks if the user is in the group. If found, returns; else, recursively calls subgroups."""    if user in group.get_users():        return True    for subgroup in group.get_groups():        #print("checking group-- ", subgroup.get_name())        return findUser(user, subgroup)            return Falsedef is_user_in_group(user, group):    return findUser(user, group)```### In the main version : **problem_4.py**Since the user data is stored in a list, for a worst case scenario where the user does not exist we will have to search the entire length of the user list. This search takes O(u) time. Searching a group takes O(g) time.Since recursion is being used to search the list, If a user does not exist in any of the groups we have to search all their subgroups as well as their user list. This search takes O(u * g) time complexity and  O(u * g) space complexity.------------### In the modified version : **problem_4_modified.py**#Assuming that I am allowed to change the Group class: The data structure used to store the users in each group was changed from a list to a dictionary. Searching this user dictionary takes O(1) constant time, and searching a group takes O(g) time complexity.In a worst case scenario searching a group along with it's subgroups takes O(u * g) time complexity because searching a user dictionary hardly affect the time taken to traverse all the groups. ```pythonclass Group(object):    def __init__(self, _name):        self.name = _name        self.groups = []        self.users = {}   #changed from list to dictionary    def add_user(self, user):        self.users[user]=user  #change to add to dictionary```------------------------------------## Udacity Project Requirement> **Active Directory**In Windows Active Directory, a group can consist of user(s) and group(s) themselves. We can construct this hierarchy as such. Where User is represented by str representing their ids.```pythonclass Group(object):    def __init__(self, _name):        self.name = _name        self.groups = []        self.users = []    def add_group(self, group):        self.groups.append(group)    def add_user(self, user):        self.users.append(user)    def get_groups(self):        return self.groups    def get_users(self):        return self.users    def get_name(self):        return self.nameparent = Group("parent")child = Group("child")sub_child = Group("subchild")sub_child_user = "sub_child_user"sub_child.add_user(sub_child_user)child.add_group(sub_child)parent.add_group(child)```Write a function that provides an efficient look up of whether the user is in a group.```pythondef is_user_in_group(user, group):    """    Return True if user is in the group, False otherwise.    Args:      user(str): user name/id      group(class:Group): group to check user membership against    """    return None```